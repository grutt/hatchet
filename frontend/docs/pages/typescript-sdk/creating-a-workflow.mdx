# Creating a Workflow

To create a workflow, simply create a new `Workflow` object.
For example, a simple 2-step workflow would look like:

```ts
import Hatchet from "@hatchet/sdk";
import { Workflow } from "@hatchet/workflow";

const hatchet = Hatchet.init();

const workflow: Workflow = {
  id: "example",
  description: "test",
  on: {
    event: "user:create",
  },
  steps: [
    {
      name: "step1",
      run: (input, ctx) => {
        console.log("executed step1!");
        return { step1: "step1" };
      },
    },
    {
      name: "step2",
      parents: ["step1"]
      run: (input, ctx) => {
        console.log("executed step2!");
        return { step2: "step2" };
      },
    },
  ],
};
```

You'll notice that the workflow defines a workflow trigger (in this case, `on_events`), and the workflow definition. The workflow definition includes a series of steps which is simply an array of `Step` objects. Each step has a `run` prop which is a function that takes an `input` and a `context`. The `context` argument is a `Context` object, which contains information about the workflow, such as the input data and the output data of previous steps.

To create multi-step workflows, you can use `parents` to define the steps which the current step depends on. In the example, `step2` will not invoke until after `step1` completes.

## Getting Access to the Input Data

You can get access to the workflow's input data, such as the event data or other specified input data, by using the `context.workflow_input()` method on the `context`. For example, given the following event:

```json
{
  "name": "test"
}
```

Here's an example `Step` which accesses the workflow input:

```ts
const stepPrintsInput: Step = {
  name: "step2",
  parents: ["step1"],
  run: (input, ctx) => {
    console.log("executed step2!", ctx.workflow_input());
  },
};
```

## Step Outputs

Step outputs should be a of type `Record<string, any>`, should be `JSON` serializable, and are optional. For example:

```py
const stepReturnsData: Step = {
    name: 'step2',
    run: (input, ctx) => {
        return { "awesome": "data" }
    },
}
```

Future steps can access this output by calling `ctx.step_output("<step_name>")`. In this example, a future step could access this data via `context.step_output("step2")`. Remember, a step that depends on previous step data should include this dependency in the `parents` array

## Cron Schedules

You can declare a cron schedule by defining `on_crons` in the `Workflow` object. For example, to trigger a workflow every 5 minutes, you can do the following:

```go
import Hatchet from '@hatchet/sdk';
import { Workflow } from '@hatchet/workflow';

const hatchet = Hatchet.init();

const workflow: Workflow = {
  id: 'example',
  description: 'test',
  on: {
    cron: "*/5 * * * *",
  },
  steps: [
    {
      name: 'step1',
      run: (input, ctx) => {
        console.log('executed step1!');
        return { step1: 'step1' };
      },
    },
    {
      name: 'step2',
      parents: ['step1'],
      run: (input, ctx) => {
        console.log('executed step2!', ctx.workflow_input());
        return { step2: 'step2' };
      },
    },
  ],
};
```
